/*
 * ADC.hpp
 *
 *  Created on: 20 oct. 2022
 *      Author: alejandro
 */

#pragma once
#include <string>

#include "HALAL/Models/PinModel/Pin.hpp"
#include "HALAL/Models/LowPowerTimer/LowPowerTimer.hpp"
#include "HALAL/Models/DMA/DMA.hpp"

#if defined(HAL_ADC_MODULE_ENABLED) && defined(HAL_LPTIM_MODULE_ENABLED)

using std::string;

#define ADC_BUF_LEN 16
#define LPTIM1_PERIOD 6875
#define LPTIM2_PERIOD 6875
#define LPTIM3_PERIOD 6875

#define ADC_MAX_VOLTAGE 3.3
#define MAX_12BIT 4095.0
#define MAX_16BIT 65535.0


/**
 * @brief A utility class that controls ADC inputs.
 *
 * This class handles the configuration, read, and correct casting of the ADC values in the ADC inputs using DMA to make cyclic reads, and the code pulls from the space given to the DMA memory.
 * For the class to work, the pins used as parameters in each inscribe has to be declared on Runes and on Pins as ADCs (change adc_instances and AF of pins, respectively).
 * Moreover, if the ADC used is not on the code generated by the .ioc you may need to change HAL_ADC_MspInit (on stm32h7xx_hal_msp.c) to configure the ADC pins and channels and their DMAs.
 * Template-project has all the adcs declared on runes and the .ioc correctly configured, so unless more are needed these configurations can be assumed.
 */
class ADC {
public:
	struct InitData {
	public:
		ADC_TypeDef* adc;
		uint32_t resolution;
		uint32_t external_trigger;
		vector<uint32_t> channels;
		DMA::Stream dma_stream;
		string name;

		InitData() = default;
		InitData(ADC_TypeDef* adc, uint32_t resolution, uint32_t external_trigger, vector<uint32_t>& channels, DMA::Stream dma_stream, string name);
	};

	class Peripheral {
	public:
		ADC_HandleTypeDef* handle;
		uint16_t* dma_data_buffer;
		LowPowerTimer timer;
		InitData init_data;
		bool is_on = false;

		Peripheral() = default;
		Peripheral(ADC_HandleTypeDef* handle, LowPowerTimer& timer, InitData& init_data);

		bool is_registered();
	};

	class Instance {
	public:
		Peripheral* peripheral;
		uint32_t channel;
		uint32_t rank;

		Instance() = default;
		Instance(Peripheral* peripheral, uint32_t channel);
	};

	/**
	 * @brief A method to add a pin as an ADC input on the ST-LIB.

	 * This method has to be invoked before the ST-LIB::start(), as it marks the pin to be configured as an ADC, and that configuration is made in the ST-LIB::start().
	 * As said on the class description, only correctly configured ADC pins will work correctly when declared as an ADC.
	 * It is forbidden to declare a pin as an ADC and as anything else on services at the same time, and it will result in undefined behavior.
	 *
	 * @param pin	the Pin to be added as an ADC
	 *
	 * @return the id that represents the ADC inside this utility class, used in all its functions.
	 */
	static uint8_t inscribe(Pin pin);

	/**
	 * @brief Method used in ST-LIBstart() to configure pins inscribed as ADCs.
	 *
	 * The start methods of the HALAL are made to be invoked in an specific order.
	 * As such, its recommended to not use them isolated, and instead use the ST-LIB::start().
	 * The If for any reason not starting a service from HALAL was desired, removing the definition of its HAL parent module would deactivate it.
	 * For example, if ADC was needed out of the code, removing define HAL_ADC_MODULE_ENABLED on stm32h7xx_hal_conf.h would result in that behavior.
	 */
	static void start();

	/**
	 * @brief Activates the ADC represented by the id.
	 *
	 * After the ADC is configured in the ST-LIBstart::() it needs to be activated with turn_on to start reading.
	 * This is made this way so the user can control exactly when the measures start to be taken.
	 * The get_value() method will only work on a Pin that has both been inscribed, started, and turned on.
	 *
	 * @param 	id	the id of ADC to be activated.
	 */
	static void turn_on(uint8_t id);

	/**
	 * @brief Returns the value of the last DMA read made by the ADC.
	 *
	 * The get_value function doesn t issue a read, but rather pulls the memory where the last read made is saved, transforms the value
	 * with the reference voltage and returns the voltage represented with that value.
	 * The capture of the value is made automatically by the DMA configured for the respective ADC channel, and the frequency of the reads is
	 * dependant on the configuration of the DMA itself.
	 *
	 * @param id	the id of the ADC to be read.
	 *
	 * @return the value of the ADC in volts. The ADC_MAX_VOLTAGE needs to be correctly configured in order for this function to work.
	 */
	static float get_value(uint8_t id);

	/**
	 * @brief Returns the value of the last DMA read made by the ADC.
	 *
	 * The get_int_value function doesn t issue a read, but rather pulls the memory where the last read made is saved and returns that value.
	 * The capture of the value is made automatically by the DMA configured for the respective ADC channel, and the frequency of the reads is
	 * dependant on the configuration of the DMA itself.
	 *
	 * @param id	the id of the ADC to be read.
	 *
	 * @return the value of the ADC, in uint16_t format. 0 is minimum possible value and max_uint16_t is the maximum.
	 */
	static uint16_t get_int_value(uint8_t id);

	/**
	 * @brief Function that returns the pointer where the DMA of the ADC writes its value, for maximum efficiency on the access
	 *
	 * This function has no protection of any kind, other that checking that an adc exists before giving the pointer back.
	 * If the ADC is running or not should be handled by the user.
	 * The adcs of the adc3 peripheral are not aligned in the buffer, and are instead aligned in the get functions.
	 * If the values are accessed from the buffer, is the responsibility of the user to handle the shift problems.
	 */
	static uint16_t* get_value_pointer(uint8_t id);

	static Peripheral peripherals[3];

private:
	static uint32_t ranks[16];
	static map<Pin, Instance> available_instances;
	static unordered_map<uint8_t, Instance> active_instances;
	static uint8_t id_counter;

	static void init(Peripheral& peripheral);
};

#endif
